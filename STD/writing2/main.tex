% Homework template for Inference and Information
% UPDATE: November 19, 2025 by Li Zhengyang
\documentclass[a4paper]{article}
\usepackage{ctex}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{moreenum}
\usepackage{mathtools}
\usepackage{url}
\usepackage{bm}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{multirow}
\usepackage{siunitx}
\usepackage{diagbox}
\lstset{
	basicstyle          =   \sffamily,          % 基本代码风格
	keywordstyle        =   \bfseries,          % 关键字风格
	commentstyle        =   \rmfamily\itshape,  % 注释的风格，斜体
	stringstyle         =   \ttfamily,  % 字符串风格
	flexiblecolumns,                % 
	numbers             =   left,   % 行号的位置在左边
	showspaces          =   false,  % 是否显示空格，显示了有点乱，所以不显示了
	numberstyle         =   \zihao{-5}\ttfamily,    % 行号的样式，小五号，tt等宽字体
	showstringspaces    =   false,
	captionpos          =   t,      % 这段代码的名字所呈现的位置，t指的是top上面
	frame               =   lrtb,   % 显示边框
}
\lstdefinestyle{Python}{
	language        =   Python, % 语言选Python
	basicstyle      =   \zihao{-5}\ttfamily,
	numberstyle     =   \zihao{-5}\ttfamily,
	keywordstyle    =   \color{blue},
	keywordstyle    =   [2] \color{teal},
	stringstyle     =   \color{magenta},
	commentstyle    =   \color{red}\ttfamily,
	breaklines      =   true,   % 自动换行，建议不要写太长的行
	columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
	basewidth       =   0.5em,
}
% \usepackage{subcaption}
\usepackage[caption=false,font=footnotesize,labelfont=rm,textfont=rm,subrefformat=parens]{subfig}
\usepackage{booktabs} % toprule
\usepackage[mathcal]{eucal}
\usepackage{color}
\usepackage{iidef}
\newif\ifans\anstrue
\newcommand{\myspace}[1]{\par\vspace{#1\baselineskip}}


\thecourseinstitute{\textnormal{视听信息系统导论}}
\theterm{确定}
\begin{document}
	
	
\vspace{3mm}
\centerline{\textbf{\Large{书面作业2}}}

\centerline{\text{姓名：李正扬\quad 学号：2023010645\quad 日期：2025年11月19日}}

\section{优化算法}

设一元函数

\centerline{$f(x)=5x^2-20x+25,\quad x_0=6$}
	
\begin{enumerate}[label=(\arabic*)]
	\item 写出$f'(x)$和$f''(x)$,，并给出最优点$x^*$(使目标函数$f(x)$取得最小值的点)。
	
	$f'(x)=10x-20$\\$f''(x)=10>0$\\令$f'(x)=0$得到$x^*=2$
	
	\item 采用固定步长$\eta=0.05$的梯度下降法，从$x_0$起做三步迭代，给出$x_1, x_2, x_3$。
	
	优化方向$\Delta x=f'(x)=10x-20$\\
	$f'(x_0)=40$, $x_1=x_0-\eta f'(x_0)=4$\\
	$f'(x_1)=20$, $x_2=x_1-\eta f'(x_1)=3$\\
	$f'(x_2)=10$, $x_3=x_2-\eta f'(x_2)=2.5$
	
	\item 用牛顿法(Newton，取步长$t=1$)从$x_0$起迭代两步，给出$x_1^{(N)}$和$x_2^{(N)}$。
	
	牛顿法的优化方向$\Delta_x=\frac{f'(x)}{f''(x)}=\frac{10x-20}{10}=x-2$\\
	$\Delta_0=x_0-2=2$, $x_1^{(N)}=x_0-t\Delta_0=2$\\
	$\Delta_1=x_1-2=0$, $x_2^{(N)}=x_1-t\Delta_1=2$\\
	
	\item 比较两种方法在第3步(若已收敛则取收敛的步数)后与最优点的距离，并说明哪个更快。
	
	固定步长的梯度下降法在第3步仍未收敛, 与最优点的距离$|x_3-x^*|=0.5$\\
	牛顿法第2步已经收敛, 与最优点的距离为0\\
	牛顿法的收敛速度更快, 1步就收敛到了最优点
	
	\item 在现代机器学习中通常更常用哪一种方法？请说明原因。
	
	更常用梯度下降法。原因：
	\begin{enumerate}
		\item 牛顿法需要计算二阶导数，计算复杂度高，且Hessian矩阵的存储和求逆计算代价大。
		\item 牛顿法是否收敛依赖于起始点的选取，否则容易不收敛或者收敛到鞍点和极大值点。
		\item 梯度下降法可以结合动量、自适应学习率等，收敛速度也得到提升。
	\end{enumerate}

\end{enumerate}

\section{图像压缩编码}
	
	图像压缩的核心思想是在尽量保持视觉质量的前提下，减少冗余信息的存储和传输。根据课上所学知识，回答问题：\par
	给定下列离散符号集及其概率，对信源进行霍夫曼编码，给出每个符号对应的码字，并计算平均码长、编码效率和压缩比。
	\[
	\begin{bmatrix*}
		x_i\\
		p_i
	\end{bmatrix*}
	=
	\begin{bmatrix*}
		x_1 & x_2 & x_3 & x_4 & x_5 & x_6\\
		0.4 & 0.2 & 0.15 & 0.12 & 0.07 & 0.06
	\end{bmatrix*}
	\]\par
	
	\begin{enumerate}[label=(\arabic*)]
		\item 合并$x_5$和$x_6$, 概率为0.13, 重新排序, $\{x_1, x_2, x_3, x_{56}, x_4\}$
		\item 合并$x_{56}$和$x_4$, 概率为0.25, 重新排序, $\{x_1, x_{564}, x_2, x_3\}$
		\item 合并$x_2$和$x_3$, 概率为0.35, 重新排序, $\{x_1, x_{23}, x_{564}\}$
		\item 合并$x_{23}$和$x_{564}$, 概率为0.60, 重新排序, $\{x_{23564}, x_1\}$
		\item 合并$x_{23564}$和$x_1$, 概率为1.00
	\end{enumerate}
	
	\noindent 得到霍夫曼编码为:\par
	$x_1$: 1\par
	$x_2$: 000\par
	$x_3$: 001\par
	$x_4$: 011\par
	$x_5$: 0100\par
	$x_6$: 0101\\
	平均码长$L=\sum p_iL_i=2.33$\\
	信息熵$H=-\sum p_i\log_2 p_i=2.27$bit\\
	编码效率$\eta=\frac{H}{L}=0.974$\\
	自然二进制码长为3\\
	压缩比$k=\frac{3}{L}=1.29$
	
\section{边缘检测}
	Sobel滤波器是一种边缘检测方法，用于图像处理和计算机视觉领域，它通过计算图像灰度值的梯度来检测边缘。根据课上所学知识，回答下列题目：
	\begin{enumerate}[label=(\arabic*)]
		\item 写出水平/垂直Sobel滤波$S_x$，$S_y$的$3\times 3$矩阵形式(省略归一化因子)。
		\item 设灰度图像
		
		\[
		I
		=
		\begin{bmatrix*}
			1  & 1  & 1  & 1  & 1  & 1\\
			1  & 1  & 1  & 1  & 1  & 1\\
			1  & 1  & 1  & 1  & 1  & 1\\
			10 & 10 & 10 & 10 & 10 & 10\\
			10 & 10 & 10 & 10 & 10 & 10\\
			10 & 10 & 10 & 10 & 10 & 10\\
		\end{bmatrix*}
		\]
		
		\noindent 使用$3\times 3$Sobel核，对$I$进行卷积（不使用padding，步长为1），分别计算\\
		\centerline{$G_x=S_x\otimes I$，$G_y=S_y\otimes I$.}\\
		给出$G_x$与$G_y$的数值矩阵；并回答：从结果看，是否成功提取出了水平边缘？请简述理由。
		
	\end{enumerate}
	
	\noindent
	(1)省略$\frac{1}{8}$归一化因子
	\[
	S_x
	=
	\begin{bmatrix*}
		-1 & 0 & 1\\
		-2 & 0 & 2\\
		-1 & 0 & 1
	\end{bmatrix*}
	,\quad
	S_y
	=
	\begin{bmatrix*}
		1 & 2 & 1\\
		0 & 0 & 0\\
		-1 & -2 & -1
	\end{bmatrix*}
	\]
	(2)\[
	G_x=S_x\otimes I
	=
	\begin{bmatrix*}
		0 & 0 & 0 & 0\\
		0 & 0 & 0 & 0\\
		0 & 0 & 0 & 0\\
		0 & 0 & 0 & 0\\
	\end{bmatrix*}
	\]
	\[
	G_y=S_y\otimes I
	=
	\begin{bmatrix*}
		0 & 0 & 0 & 0\\
		-36 & -36 & -36 & -36\\
		-36 & -36 & -36 & -36\\
		0 & 0 & 0 & 0\\
	\end{bmatrix*}
	\]
	从结果看，成功提取出了水平边缘。原因：\par
	图像亮度在输入的第3行与第4行之间发生突变，为明显的水平边缘。$G_y$在对应位置(输出的第2行与第3行)产生了显著的负响应(-36)，而其他非边缘区域卷积结果接近0，说明Sobel 垂直核$S_y$成功检测出了图像中的水平边缘。
	
\section{分类评价指标}
	某模型在二分类任务(正类为Positive，负类为Negative)上的测试结果如下\par
	\begin{table}[h]
		\centering
		\begin{tabular}{|c|c|c|}
			\hline
			\diagbox{Truth}{Prediction} & positive & negative \\ \hline
			positive                    & 50       & 10       \\ \hline
			negative                    & 5        & 35       \\ \hline
		\end{tabular}
	\end{table}
	请计算：准确率(Accuracy)，精确率(Precision)，召回率(Recall)，F1 分数(F1 Score)。\\
	
	\noindent
	根据混淆矩阵，有TP=50, TN=35, FP=5, FN=10，则：\\
	准确率\\\centerline{$Accuracy=\frac{TP+TN}{TP+TN+FP+FN}=0.85$}\\
	精确率\\\centerline{$Precion=\frac{TP}{TP+FP}=0.909$}\\
	召回率\\\centerline{$Recall=\frac{TP}{TP+FN}=0.833$}\\
	F1 分数\\\centerline{$F1\quad Score=\frac{2\times(Presion\times Recall)}{Precion+Recall}=0.87$}
	
\section{图像分类网络}
	GoogleNet是经典的图像分类网络，从Inception v1-v4 的迭代，反应了神经网络的发展。其中，Inception v2引入了BN(Batch Normalization)，同时将 Inception 模块中的$5\times 5$卷积变成了两个$3\times 3$卷积的堆叠，如图所示，计算：\par
	
	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.2]{pics/1.png}
	\end{figure}
	
	\begin{enumerate}[label=(\arabic*)]
		\item 假设输入维度为$3\times 3\times 1$，模块内所有卷积核的步长为$1$，Max-Pool的大小为$3\times 3$，经过一个模块后，为使得所有运算结果能直接在通道数维度上累加, 即输出维度为$3\times 3\times 4$，写出不同尺寸卷积核和Max-Pool的padding长度。
		
		\item 假设输入如下，假设所有卷积核的每个元素均为$1$，在(1)的假设下计算经过一个模块后的输出结果(4个通道)。
		\begin{table}[h]
			\centering
			\begin{tabular}{|c|c|c|}
				\hline
				1 & 2 & 1\\ \hline
				2 & 4 & 2\\ \hline
				1 & 2 & 1\\ \hline
			\end{tabular}
		\end{table}
		
	\end{enumerate}
	
	\noindent
	(1)卷积层输出尺寸公式\\
	\centerline{$W_2=\frac{W_1-F+2P}{S}+1$}
	\centerline{$H_2=\frac{H_1-F+2P}{S}+1$}
	根据题目有$W_1=H_1=W_2=H_2=3$，$S=1$\\
	$1\times 1$卷积核，$F=1$\\
	\centerline{$3-1+2P+1=3\Rightarrow P=0$}
	$3\times 3$卷积核，$F=3$\\
	\centerline{$3-3+2P+1=3\Rightarrow P=1$}
	$3\times 3$ MaxPool\\
	\centerline{为了保持输出仍然为$3\times 3$，同样需要$P=1$}
	(2)四个通道分别计算如下：
	\begin{enumerate}[label=(\alph*)]
		\item 通道1
		经过$1\times 1$，$3\times 3$，$3\times 3$三个卷积核后的输出分别为\\
		\[
		\begin{bmatrix*}
			1 & 2 & 1\\
			2 & 4 & 2\\
			1 & 2 & 1
		\end{bmatrix*}
		,
		\begin{bmatrix*}
			9 & 12 & 9\\
			12 & 16 & 12\\
			9 & 12 & 9
		\end{bmatrix*}
		,
		\begin{bmatrix*}
			49 & 70 & 49\\
			70 & 100 & 70\\
			49 & 70 & 49
		\end{bmatrix*}
		\]
		
		\item 通道2
		经过$1\times 1$，$3\times 3$两个卷积核后的输出分别为\\
		\[
		\begin{bmatrix*}
			1 & 2 & 1\\
			2 & 4 & 2\\
			1 & 2 & 1
		\end{bmatrix*}
		,
		\begin{bmatrix*}
			9 & 12 & 9\\
			12 & 16 & 12\\
			9 & 12 & 9
		\end{bmatrix*}
		\]
		
		\item 通道3
		经过$1\times 1$卷积核和$3\times 3$ MaxPool后的输出分别为\\
		\[
		\begin{bmatrix*}
			1 & 2 & 1\\
			2 & 4 & 2\\
			1 & 2 & 1
		\end{bmatrix*}
		,
		\begin{bmatrix*}
			4 & 4 & 4\\
			4 & 4 & 4\\
			4 & 4 & 4
		\end{bmatrix*}
		\]
		
		\item 通道4
		经过三个$1\times 1$卷积核后的输出为\\
		\[
		\begin{bmatrix*}
			1 & 2 & 1\\
			2 & 4 & 2\\
			1 & 2 & 1
		\end{bmatrix*}
		\]
	\end{enumerate}
	
\end{document}